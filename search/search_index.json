{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"docker/docker_daemon/","title":"docker daemon","text":""},{"location":"docker/docker_daemon/#logging","title":"logging","text":""},{"location":"docker/docker_daemon/#log-driver","title":"log-driver","text":"<p>defines the driver you want to use. <code>json-file</code> is for local logging with builtin logrotating</p>"},{"location":"docker/docker_daemon/#log-opts","title":"log-opts","text":"<p>You can define the <code>max-size</code> and the <code>max-file</code> with those options. Docker automatilicly rotates the local files. Enable <code>compress</code> so docker compresses the rotated files.</p>"},{"location":"docker/docker_daemon/#isolate-containers-with-a-user-namespace","title":"Isolate containers with a user namespace","text":"<p>https://docs.docker.com/engine/security/userns-remap/ With <code>userns-remap</code> docker remaps the root user inside to docker container to a local low-priviled user.</p>"},{"location":"docker/docker_daemon/#live-restore","title":"live-restore","text":"<p>https://docs.docker.com/config/containers/live-restore/</p> <p>Allows container to run, even the docker daemon gets restarted. The live restore option helps reduce container downtime due to daemon crashes, planned outages, or upgrades.</p>"},{"location":"docker/docker_daemon/#example","title":"Example","text":"<pre><code>{\n\"log-driver\": \"json-file\",\n\"log-opts\": {\n\"max-size\": \"50m\",\n\"max-file\": \"10\",\n\"compress\": \"true\"\n},\n\"userns-remap\": \"default\",\n\"live-restore\": true\n}\n</code></pre>"},{"location":"pacemaker/custom_ocf/iptables_rule/","title":"Iptables rule","text":"iptables rule - OCF Resource Agent<pre><code>#!/bin/sh\n# Borrowed from chriscowley\n# https://gist.github.com/chriscowley/bdd466a09b13ca676af2\n#\n#       OCF Resource Agent compliant resource script.\n#\n# Copyright (c) 2009 IN-telegence GmbH &amp; Co. KG, Dominik Klein\n#                    All Rights Reserved.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of version 2 of the GNU General Public License as\n# published by the Free Software Foundation.\n#\n# This program is distributed in the hope that it would be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n#\n# Further, this software is distributed without any warranty that it is\n# free of the rightful claim of any third person regarding infringement\n# or the like.  Any license provided herein, whether implied or\n# otherwise, applies only to this software file.  Patent licenses, if\n# any, provided herein do not apply to combinations of this program with\n# other software, or any other product whatsoever.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write the Free Software Foundation,\n# Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.\n# OCF instance parameters\n#       OCF_RESKEY_chain\n#       OCF_RESKEY_source\n#       OCF_RESKEY_protocol\n#       OCF_RESKEY_ports\n#       OCF_RESKEY_action\n#\n# This RA adds a rule to an iptables firewall\n# Monitoring is done through checking the output of iptables -L\n# Initialization:\n: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}\n. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs\n\niptables_rule_status() {\nif  [ $(/sbin/iptables -nL | grep  ${OCF_RESKEY_source} | grep ${OCF_RESKEY_protocol} | grep  ${OCF_RESKEY_ports} | grep ${OCF_RESKEY_action}  | wc -l) -eq 1 ]\nthen\nreturn $OCF_RUNNING\nelse\nreturn $OCF_NOT_RUNNING\nfi\n}\niptables_rule_start() {\nif ! iptables_status\n    then\ncmd=\"/sbin/iptables -A ${OCF_RESKEY_chain} -s ${OCF_RESKEY_source} -p ${OCF_RESKEY_protocol} --dport ${OCF_RESKEY_ports} -j ${OCF_RESKEY_action}\"\nocf_log debug \"Adding rule -s ${OCF_RESKEY_source} -p ${OCF_RESKEY_protocol} --dport ${OCF_RESKEY_ports} -j ${OCF_RESKEY_action} to ${OCF_RESKEY_chain} chain\"\neval ${cmd}\nif iptables_rule_status\n        then\nocf_log debug \"Rule: -s ${OCF_RESKEY_source} -p ${OCF_RESKEY_protocol} --dport ${OCF_RESKEY_ports} -j ${OCF_RESKEY_action} added to  ${OCF_RESKEY_chain} successfully\"\nreturn $OCF_SUCCESS\nelse\nocf_log err \"Could not add rule\"\nreturn $OCF_ERR_GENERIC\nfi\nelse\n# If already running, consider start successful\nocf_log debug \"Rule already exists\"\nreturn $OCF_SUCCESS\nfi\n}\niptables_rule_stop() {\nif [ -n \"$OCF_RESKEY_stop_timeout\" ]\nthen\nstop_timeout=$OCF_RESKEY_stop_timeout\nelif [ -n \"$OCF_RESKEY_CRM_meta_timeout\" ]; then\n# Allow 2/3 of the action timeout for the orderly shutdown\n# (The origin unit is ms, hence the conversion)\nstop_timeout=$((OCF_RESKEY_CRM_meta_timeout/1500))\nelse\nstop_timeout=10\nfi\nif iptables_rule_status\n    then\ncmd=\"/sbin/iptables -D ${OCF_RESKEY_chain} -s ${OCF_RESKEY_source} -p ${OCF_RESKEY_protocol} --dport ${OCF_RESKEY_ports} -j ${OCF_RESKEY_action}\"\neval ${cmd}\ni=0\nwhile [ $i -lt ${stop_timeout}]\ndo\nif ! iptables_rule_status\n            then\nreturn ${OCF_SUCCESS}\nfi\nsleep 1\ni=$((i+1))\ndone\nocf_log warn \"Could not remove rule\"\nreturn $OCF_ERR_GENERIC\nelse\n# Rule not in table\nreturn $OCF_SUCCESS\nfi\n}\niptables_rule_monitor() {\niptables_rule_status\n    ret=$?\nif [ $ret -eq $OCF_SUCCESS ]\nthen\nreturn $ret\nfi\n}\n# FIXME: Attributes special meaning to the resource id\nif [ -z ${OCF_RESKEY_chain} ]\nthen\nchain=\"$OCF_RESKEY_chain\"\nelse\nchain=\"INPUT\"\nfi\nif [ -z \"${OCF_RESKEY_source}\"]\nthen\nsource=\"$OCF_RESKEY_source\"\nelse\nsource=\"0.0.0.0\"\nfi\nif [ -z ${OCF_RESKEY_protocol} ]\nthen\nprotocol=\"$OCF_RESKEY_protocol\"\nelse\nprotocol=\"tcp\"\nfi\nif [ -z ${OCF_RESKEY_action} ]\nthen\naction=\"$OCF_RESKEY_action\"\nelse\naction=\"ACCEPT\"\nfi\nports=\"$OCF_RESKEY_ports\"\nfunction valid_ip() {\nlocal  ip=$1\nlocal  stat=1\nif [[ $ip =~ ^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$ ]]; then\nOIFS=$IFS\nIFS='.'\nip=($ip)\nIFS=$OIFS\n[[ ${ip[0]} -le 255 &amp;&amp; ${ip[1]} -le 255 \\\n&amp;&amp; ${ip[2]} -le 255 &amp;&amp; ${ip[3]} -le 255 ]]\nstat=$?\nfi\nreturn $stat\n}\niptables_rule_validate() {\nif [ `/sbin/iptables -L | grep 'Chain' | grep ${chain}` -nq 1 ]\nthen\nocf_log err \"Chain ${chain} does not exist in iptables\"\nexit $OCF_ERR_INSTALLED\nfi\nif [ ! valid_ip ${source} ]\nthen\nocf_log err \"${source} is not a valid IP address\"\nexit $OCF_ERR_INSTALLED\nfi\nif [ ${protocol} != 'tcp' || ${protocol} != 'udp']\nthen\nocf_log err \"${protocol} is not a valid protocol\"\nexit $OCF_ERR_INSTALLED\nfi\nif [ ${ports} != [0-9*] || ${ports} != [0-9*]:[0-9]* ]\nthen\nocf_log err \"${ports} is not a valid port range\"\nexit $OCF_ERR_INSTALLED\nfi\nif [ ${action} != \"ACCEPT\" || ${action} != \"REJECT\" || ${action} != \"DROP\" || ${action} != \"LOG\"]\nthen\nocf_log err \"${action} is not a valid action\"\nexit $OCF_ERR_INSTALLED\nfi\nreturn $OCF_SUCCESS\n}\nanything_meta() {\ncat &lt;&lt;END\n&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE resource-agent SYSTEM \"ra-api-1.dtd\"&gt;\n&lt;resource-agent name=\"iptables_rule\"&gt;\n&lt;version&gt;1.0&lt;/version&gt;\n&lt;longdesc lang=\"en\"&gt;\nThis is an OCF RA to add an Iptables rule\n&lt;/longdesc&gt;\n&lt;shortdesc lang=\"en\"&gt;Adds an Iptables rule&lt;/shortdesc&gt;\n&lt;parameters&gt;\n&lt;parameter name=\"chain\" required=\"0\"&gt;\n&lt;longdesc lang=\"en\"&gt;\nThe firewall chain to add the rule to\n&lt;/longdesc&gt;\n&lt;shortdesc lang=\"en\"&gt;Firewall chain to add the rule to&lt;/shortdesc&gt;\n&lt;content type=\"string\" default=\"\"/&gt;\n&lt;/parameter&gt;\n&lt;parameter name=\"source\" required=\"0\"&gt;\n&lt;longdesc lang=\"en\"&gt;\nSource address for traffic. Defaults to 0.0.0.0 (anywhere)\n&lt;/longdesc&gt;\n&lt;shortdesc lang=\"en\"&gt;Source address&lt;/shortdesc&gt;\n&lt;content type=\"string\" /&gt;\n&lt;/parameter&gt;\n&lt;parameter name=\"protocol\" required=\"0\"&gt;\n&lt;longdesc lang=\"en\"&gt;\nProtocol, defaults to \"tcp\"\n&lt;/longdesc&gt;\n&lt;shortdesc lang=\"en\"&gt;protocol&lt;/shortdesc&gt;\n&lt;content type=\"string\" default=\"tcp\"/&gt;\n&lt;/parameter&gt;\n&lt;parameter name=\"ports\" required=\"1\"&gt;\n&lt;longdesc lang=\"en\"&gt;\nPorts to process. Can be either a port (80), or a range (6000:6033)\n&lt;/longdesc&gt;\n&lt;shortdesc lang=\"en\"&gt;ports to process&lt;/shortdesc&gt;\n&lt;/parameter&gt;\n&lt;parameter name=\"action\" &gt;\n&lt;longdesc lang=\"en\"&gt;\nWhat to do with the traffic. Can be one of ACCEPT, REJECT, DROP or LOG. Default to ACCEPT\n&lt;/longdesc&gt;\n&lt;shortdesc lang=\"en\"&gt;What to do with the traffic&lt;/shortdesc&gt;\n&lt;/parameter&gt;\n&lt;/parameters&gt;\n&lt;actions&gt;\n&lt;action name=\"start\"   timeout=\"20s\" /&gt;\n&lt;action name=\"stop\"    timeout=\"20s\" /&gt;\n&lt;action name=\"monitor\" depth=\"0\"  timeout=\"20s\" interval=\"10\" /&gt;\n&lt;action name=\"meta-data\"  timeout=\"5\" /&gt;\n&lt;action name=\"validate-all\"  timeout=\"5\" /&gt;\n&lt;/actions&gt;\n&lt;/resource-agent&gt;\nEND\nexit 0\n}\ncase \"$1\" in\nmeta-data|metadata|meta_data)\niptables_rule_meta  ;;\nstart)\niptables_rule_start\n    ;;\nstop)\niptables_rule_stop\n    ;;\nmonitor)\niptables_rule_monitor\n    ;;\nvalidate-all)\niptables_rule_validate\n    ;;\n*)\nocf_log err \"$0 was called with unsupported arguments: $*\"\nexit $OCF_ERR_UNIMPLEMENTED\n;;\nesac\n</code></pre>"}]}